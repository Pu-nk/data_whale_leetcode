# data_whale_leetcode
A camp for leetcode in DataWhale
---
## Day 1  哈希表
### 哈希表基础
哈希表(Hash Table)：也叫散列表（字典），根据键对值进行索引的数据结构。也就是说通过一个 `key`和映射函数`Hash(key)`计算出对应的值 `value`，把关键码值映射到一个位置来访问记录（所以映射的实际还是储存变量的位置），以加快查找的速度，这个函数叫做**哈希函数**，存放记录的数组叫做**哈希表**
哈希表的关键思想是通过哈希函数将键`key`映射到对应表中的某个区块，可以将算法拆分为两部分：
- 向哈希表插入一个关键字，并将对应值存放到表中的对应区块
- 在哈希表中通过相同的哈希函数搜索关键字对应区块中的值
用**查字典**来距举例，假设要查找赞字，那么拼音 zan 就是`key`，根据拼音找到对应页码 599的过程就是哈希函数，而页码 599 就是实际储存变量的哈希地址
### 哈希函数
**哈希函数**：将哈希表中元素的关键键值映射为元素储存位置的函数
哈希函数应当满足的条件：
- 简洁性，并尽可能使索引值分布均匀
- 哈希值是一个固定长度的输出
- `Hash(key1)`不等于 `Hash(key2)`，那么`key1`和`key2`一定不相等
- `Hash(key1)`等于 `Hash(key2)`，那么`key1`和`key2`不一定想等（哈希碰撞）
#### 直接定址法
取关键字的某个线性函数作为哈希地址。`Hash(key) = key` 或者`Hash(key) =a*key+b `
- 优点：简单，不容易造成冲突
- 缺点：如果关键字分布不连续，会造成内存的浪费
#### 除留余数法
假设哈希表的表长为`m`，取一个不大于`m`但接近或等于`m`的质数`p`，利用取模运算将关键字转化为哈希地址。
>Q: 为什么要选择素数？
> A: 一般选取素数或者`m`可以尽可能的避免冲突
#### 平方取中法
先求关键字的平方来扩大相近数之间的差别，然后根据表长度选取中间的几位数作为哈希地址，例如`Hash(key)=(key * key) //100 % 1000`，先计算平方然后去除末尾的两位数然后再去中间的三位数作为哈希地址（**如果键很多怎么办？**）
- 优点：关键字中间几位数和原关键字的每一位数都相关，所以产生的哈希地址比较均匀

#### 基数转换法
将原来的关键值看成另一种进制的数再换成原来的进制，然后选其中几位作为哈希地址 
$343246_{13} = 3 \times 13^5 + 4 \times 13^4 + 3 \times 13^3 + 2 \times 13^2 + 4 \times 13^1 + 6 \times 13^0 = 1235110_{10}$
### 哈希冲突
**哈希冲突(Hash Collision)**：不同的关键字可能根据同一个哈希函数得到同一个哈希地址，这种现象叫做哈希冲突
一般针对哈希冲突的解决方法主要包括两类：
- 开放地址法(open addressing)
- 链地址法(Chaining)
#### 开放地址法
**开放地址法**是指将哈希表中的空地址向冲突的哈希地址开放，当哈希表未满时，可以尝试其他的单元直到找到空的单元为止
当发生冲突时，开放地址按照下面的方法求得后继哈希地址：$H(i) = (Hash(key)+F(i))%m$，$i=1,2,3,...,n(n\leq m-1)$，其中`H(i)`是在处理冲突后得到的新的哈希地址，即在第一次冲突时经过处理得到一个新地址`H(1)`，如果仍然发生冲突就如此往复继续进行处理，直到找到`H(n)`不再发生冲突
`F(i)`代表解决冲突的方法，取法可以包括：
- 线性探测法：$F(i)=1,2,3,\cdots,m-1$
- 二次探测法：$F(i) = 1^2, -1^2, 2^2, -2^2, ..., \pm n^2(n \le m / 2)$。
- 伪随机数序列
举个例子说说明一下如何用以上三种冲突解决方法处理冲突，并得到新地址 `H(i)`。例如，在长度为 11 的哈希表中已经填有关键字分别为 28、49、18 的记录（哈希函数为 `Hash(key) = key % 11`）。现在将插入关键字为 38 的新纪录。根据哈希函数得到的哈希地址为 5，产生冲突。接下来分别使用这三种冲突解决方法处理冲突。
使用线性探测法：得到下一个地址 `H(1) = (5 + 1) % 11 = 6`，仍然冲突；继续求出 `H(2) = (5 + 2) % 11 = 7`，仍然冲突；继续求出 `H(3) = (5 + 3) % 11 = 8`，8 对应的地址为空，处理冲突过程结束，记录填入哈希表中序号为 8 的位置。
使用二次探测法：得到下一个地址 `H(1) = (5 + 1*1) % 11 = 6`，仍然冲突；继续求出 `H(2) = (5 - 1*1) % 11 = 4`，4 对应的地址为空，处理冲突过程结束，记录填入哈希表中序号为 4 的位置。
使用伪随机数序列：假设伪随机数为 9，则得到下一个地址 `H(1) = (9 + 5) % 11 = 3`，3 对应的地址为空，处理冲突过程结束，记录填入哈希表中序号为 3 的位置。
使用这三种方法处理冲突的结果如下图所示：
![](/_image/2022-05-16/72fd6d4ad61e0eff4f06e5894e8dc707.png?c=1)
#### 链地址法
**链地址法(Chaining)**：将具有相同哈希地址的元素（或记录）存储在同一个线性链表中。
链地址法是一种更加常用的哈希冲突解决方法。相比于开放地址法，链地址法更加简单。
我们假设哈希函数产生的哈希地址区间为 `[0, m - 1]`，哈希表的表长为 m。则可以将哈希表定义为一个有 m 个头节点组成的链表指针数组 T。
这样在插入关键字的时候，我们只需要通过哈希函数 `Hash(key)`计算出对应的哈希地址 i，然后将其以链表节点的形式插入到以 `T[i]`为头节点的单链表中。在链表中插入位置可以在表头或表尾，也可以在中间。如果每次插入位置为表头，则插入操作的时间复杂度为 $O(1)$。
而在在查询关键字的时候，我们只需要通过哈希函数 `Hash(key)`计算出对应的哈希地址 i，然后将对应位置上的链表整个扫描一遍，比较链表中每个链节点的键值与查询的键值是否一致。查询操作的时间复杂度跟链表的长度 k 成正比，也就是 $O(k)$。对于哈希地址比较均匀的哈希函数来说，理论上讲，`k = n // m`，其中 n 为关键字的个数，m 为哈希表的表长。
举个例子来说明如何使用链地址法处理冲突。假设现在要存入的关键字集合 `keys = [88, 60, 65, 69, 90, 39, 07, 06, 14, 44, 52, 70, 21, 45, 19, 32]`。再假定哈希函数为 `Hash(key) = key % 13`，哈希表的表长 m = 13，哈希地址范围为 `[0, m - 1]`。将这些关键字使用链地址法处理冲突，并按顺序加入哈希表中（图示为插入链表表尾位置），最终得到的哈希表如下图所示。
**相对于开放地址法，采用链地址法处理冲突要多占用一些存储空间（主要是链节点占用空间）。但它可以减少在进行插入和查找具有相同哈希地址的关键字的操作过程中的平均查找长度。**这是因为在链地址法中，待比较的关键字都是具有相同哈希地址的元素，而在开放地址法中，待比较的关键字不仅包含具有相同哈希地址的元素，而且还包含哈希地址不相同的元素。
### 哈希表总结
本文讲解了一些比较基础、偏理论的哈希表知识。包含哈希表的定义，哈希函数、哈希冲突以及哈希冲突的解决方法。
- 哈希表（Hash Table）：通过键 key 和一个映射函数 Hash(key) 计算出对应的值 value，把关键码值映射到表中一个位置来访问记录，以加快查找的速度。
- 哈希函数（Hash Function）：将哈希表中元素的关键键值映射为元素存储位置的函数。
- 哈希冲突（Hash Collision）：不同的关键字通过同一个哈希函数可能得到同一哈希地址。
- 哈希表的两个核心问题是：「哈希函数的构建」 和 「哈希冲突的解决方法」。
- 常用的哈希函数方法有：直接定址法、除留余数法、平方取中法、基数转换法、数字分析法、折叠法、随机数法、乘积法、点积法等。
- 常用的哈希冲突的解决方法有两种：开放地址法和链地址法。




## Day 3 字符串匹配

### 125. 验证回文字符串
给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。
说明：本题中，我们将空字符串定义为有效的回文串。
示例 1:
```python
输入: ”A man, a plan, a canal: Panama“
输出: true
解释：”amanaplanacanalpanama“ 是回文串
```
示例 2:
```python
输入: ”race a car“
输出: false
解释：”raceacar“ 不是回文串
```
提示：
`1 <= s.length <= 2 * 105`
字符串 s 由 ASCII 字符组成

#### 解法 1 双指针
```python
class Solution(object):
    def isPalindrome(self, s):
        “””
        :type s: str
        :rtype: bool
        “””
        if s == ‘’: # 判断空字符串
            return True
        start,end=0, len(s)-1 # 定义头尾指针
        while start < end:
            if not (s[start].isalpha() or s[start].isdigit()): # 如果不满足条件，跳到下一个值
                start += 1
                continue
            if not (s[end].isalpha() or s[end].isdigit()): # 同上
                end -= 1
                continue
            if s[start].lower() != s[end].lower(): # 如果头尾不相等，返回 false
                return False
            start += 1 # 进位
            end   -= 1
        return True
```
#### 解法 2 pythonic 
```python
class Solution(object):
    def isPalindrome(self, s):
        “””
        :type s: str
        :rtype: bool
        “””
        sf = ‘’.join(filter(lambda x: x.isalpha() or x.isdigit(), s.lower()))
        # print(sf)
        if sf == sf[::-1]: return True
        return False
```

#### 344. 反转字符串
编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。
不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。
示例 1：
```
输入：s = [”h“,”e“,”l“,”l“,”o“]
输出：[”o“,”l“,”l“,”e“,”h“]
```
示例 2：
```
输入：s = [”H“,”a“,”n“,”n“,”a“,”h“]
输出：[”h“,”a“,”n“,”n“,”a“,”H“]
```
提示：
`1 <= s.length <= 105`
`s[i]` 都是 ASCII 码表中的可打印字符

